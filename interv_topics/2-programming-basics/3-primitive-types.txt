Primitive Data Types:
    is data that is not an object and has no methods or properties. There are 7 primitive data types:
    string, number, bigint, boolean, undefined, symbol, null

String 
    Template literals --- string interpolation
    Wrapper object for using methods. After the use, the wrapper object is disposed
    Difference between slice() and substring():
        These two methods are almost identical, except for a few differences. One of them is that if the first index passed to substring() is greater than the second index, the two arguments are exchanged so that a string is still returned. In the same scenario, the slice() method returns an empty string instead:
    split() have optional second argument for maximum pieces

    Iterator:
    const str = 'The quick red fox jumped over the lazy dog\'s back.';

    const iterator = str[Symbol.iterator]();
    let theChar = iterator.next();

    while (!theChar.done) {
    console.log(theChar.value);
    theChar = iterator.next();
    // Expected output: "T"
    //                  "h"
    //                  "e"
    //                   ...
    }

    String() works with null and undefined, but toString() will raise error
-------------------------------------------------------------
Number:
    Regular numbers - 64-bit format IEEE-754, also known as “double precision floating point numbers”
    BigInt numbers - represent integers of arbitrary length. They are sometimes needed because a regular integer number can’t safely exceed (253-1) or be less than -(253-1)

    Syntactic sugar:
    let billion = 1_000_000_000;

    let billion = 1e9;  // 1 billion, literally: 1 and 9 zeroes

    alert( 7.3e9 );  // 7.3 billions (same as 7300000000 or 7_300_000_000)

    1e3 === 1 * 1000; // e3 means *1000
    1.23e6 === 1.23 * 1000000; // e6 means *1000000

    let mcs = 1e-6; // five zeroes to the left from 1

    // -3 divides by 1 with 3 zeroes
    1e-3 === 1 / 1000; // 0.001

    // -6 divides by 1 with 6 zeroes
    1.23e-6 === 1.23 / 1000000; // 0.00000123

    // an example with a bigger number
    1234e-2 === 1234 / 100; // 12.34, decimal point moves 2 times

    Hex, binary and octal:

    alert( 0xff ); // 255
    alert( 0xFF ); // 255 (the same, case doesn't matter)

    let a = 0b11111111; // binary form of 255
    let b = 0o377; // octal form of 255

    alert( a == b ); // true, the same number 255 at both side
-----------------------------------------
    toString(base)
    alert( 123456..toString(36) ); // 2n9c

    Dont forget of MAth methods to round and toFixed(), that returns string
